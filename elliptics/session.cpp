/*
 * 2013+ Copyright (c) Anton Tyurin <noxiouz@yandex.ru>
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#include "session.h"
#include <errno.h>

using namespace ioremap;
namespace ph = std::placeholders;

extern "C" {

//This header is generated by cgo in compile time
#include "_cgo_export.h"

struct go_data_pointer new_data_pointer(char *data, int size) {
	return go_data_pointer {
		data, size
	};
};

void on_finish(context_t context, const elliptics::error_info &error)
{
	go_error err;
	err.code = error.code();
	err.flags = 0;
	err.message = error.message().c_str();

	go_final_callback(&err, context);
}

ell_session *new_elliptics_session(ell_node *node)
{
	ell_session *session = new elliptics::session(*node->node());
	session->set_exceptions_policy(elliptics::session::no_exceptions);
	// do not set negative/all filters without checking all callbacks,
	// they expect only valid values
	//session->set_filter(elliptics::filters::all);
	return session;
}

ell_session *clone_session(ell_session *session)
{
	return new elliptics::session(*session);
}


void delete_session(ell_session *session)
{
	delete session;
}

void session_set_filter_all(ell_session *session)
{
	session->set_filter(elliptics::filters::all);
}
void session_set_filter_positive(ell_session *session)
{
	session->set_filter(elliptics::filters::positive);
}

void session_set_groups(ell_session *session, uint32_t *groups, int count)
{
	std::vector<int>g(groups, groups + count);
	session->set_groups(g);
}

void session_set_namespace(ell_session *session, const char *name, int nsize)
{
	session->set_namespace(name, nsize);
}

void session_set_timeout(ell_session *session, int timeout)
{
	session->set_timeout(timeout);
}

void session_set_cflags(ell_session *session, cflags_t cflags)
{
	session->set_cflags(cflags);
}

void session_set_ioflags(ell_session *session, uint32_t ioflags)
{
	session->set_ioflags(ioflags);
}

void session_set_trace_id(ell_session *session, trace_id_t trace_id)
{
	session->set_trace_id(trace_id);
}

trace_id_t session_get_trace_id(ell_session *session)
{
	return session->get_trace_id();
}

void session_set_timestamp(ell_session *session, const struct dnet_time *ts)
{
	session->set_timestamp(ts);
}

void session_get_timestamp(ell_session *session, struct dnet_time *ts)
{
	session->get_timestamp(ts);
}

long session_get_timeout(ell_session *session)
{
	return session->get_timeout();
}

cflags_t session_get_cflags(ell_session *session)
{
	return session->get_cflags();
}

ioflags_t session_get_ioflags(ell_session *session)
{
	return session->get_ioflags();
}

const char *session_transform(ell_session *session, const char *key)
{
	dnet_raw_id id;
	session->transform(key, id);
	return dnet_dump_id_str_full(id.id);
}

/*
 * Read
 */
static void on_read(context_t context, context_t buffer, const elliptics::read_result_entry &result)
{
	if (result.error()) {
		elliptics::error_info einfo = result.error();
		go_error err {
			result.error().code(),
			result.command()->flags,
			einfo.message().c_str()
		};

		go_read_error(result.command(), result.address(), &err, context);
	} else {
		elliptics::data_pointer data(result.file());
		go_read_result to_go {
			result.command(), result.address(),
			result.io_attribute(), (const char *)data.data(), data.size()
		};

		go_read_callback(&to_go, context, buffer);
	}
}

void session_read_data_into(ell_session *session, context_t on_chunk_context, context_t buf_context,
		       context_t final_context, ell_key *key, uint64_t offset, uint64_t size)
{
	using namespace std::placeholders;
	session->read_data(*key, offset, size).connect(std::bind(&on_read, on_chunk_context, buf_context, _1),
				      std::bind(&on_finish, final_context, _1));
}

void session_read_data(ell_session *session, context_t on_chunk_context,
		       context_t final_context, ell_key *key, uint64_t offset, uint64_t size)
{
	using namespace std::placeholders;
	session->read_data(*key, offset, size).connect(std::bind(&on_read, on_chunk_context, 0, _1),
				      std::bind(&on_finish, final_context, _1));
}

/*
 * Write and Lookup
 */
static void on_lookup(context_t context, const elliptics::lookup_result_entry & result)
{
	if (result.error()) {
		elliptics::error_info einfo = result.error();
		go_error err {
			result.error().code(),
			result.command()->flags,
			einfo.message().c_str()
		};

		go_lookup_error(result.command(), result.address(), &err, context);
	} else {
		go_lookup_result to_go {
			result.command(), result.address(),
			result.file_info(), result.storage_address(), result.file_path()
		};

		go_lookup_callback(&to_go, context);
	}
}

void session_write_data(ell_session *session, context_t on_chunk_context,
			context_t final_context, ell_key *key, uint64_t offset,
			char *data, uint64_t size)
{
	using namespace std::placeholders;

	elliptics::data_pointer tmp = elliptics::data_pointer::from_raw(data, size);
	session->write_data(*key, tmp, offset).connect(std::bind(&on_lookup, on_chunk_context, _1),
				       std::bind(&on_finish, final_context, _1));
}

void session_write_prepare(ell_session *session, context_t on_chunk_context,
			context_t final_context, ell_key *key,
			uint64_t offset, uint64_t total_size,
			char *data, uint64_t size)
{
	using namespace std::placeholders;

	elliptics::data_pointer tmp = elliptics::data_pointer::from_raw(data, size);
	session->write_prepare(*key, tmp, offset, total_size).connect(std::bind(&on_lookup, on_chunk_context, _1),
				       std::bind(&on_finish, final_context, _1));
}

void session_write_plain(ell_session *session, context_t on_chunk_context,
			context_t final_context, ell_key *key,
			uint64_t offset,
			char *data, uint64_t size)
{
	using namespace std::placeholders;

	elliptics::data_pointer tmp = elliptics::data_pointer::from_raw(data, size);
	session->write_plain(*key, tmp, offset).connect(std::bind(&on_lookup, on_chunk_context, _1),
				       std::bind(&on_finish, final_context, _1));
}

void session_write_commit(ell_session *session, context_t on_chunk_context,
			context_t final_context, ell_key *key,
			uint64_t offset,
			uint64_t commit_size,
			char *data, uint64_t size)
{
	using namespace std::placeholders;

	elliptics::data_pointer tmp = elliptics::data_pointer::from_raw(data, size);
	session->write_commit(*key, tmp, offset, commit_size).connect(std::bind(&on_lookup, on_chunk_context, _1),
				       std::bind(&on_finish, final_context, _1));
}

void session_lookup(ell_session *session, context_t on_chunk_context,
		    context_t final_context, ell_key *key)
{
	using namespace std::placeholders;
	session->lookup(*key).connect(std::bind(&on_lookup, on_chunk_context, _1),
				      std::bind(&on_finish, final_context, _1));
}

void session_parallel_lookup(ell_session *session, context_t on_chunk_context,
		    context_t final_context, ell_key *key)
{
	using namespace std::placeholders;
	session->parallel_lookup(*key).connect(std::bind(&on_lookup, on_chunk_context, _1),
				      std::bind(&on_finish, final_context, _1));
}

/*
 * Remove
 * @on_remove() callback converts returned command into golang DnetCmd
 */
static void on_remove(context_t context, const elliptics::remove_result_entry &result)
{
	go_remove_result res {
		result.command()
	};

	go_remove_callback(&res, context);
}

void session_remove(ell_session *session, context_t on_chunk_context,
		    context_t final_context, ell_key *key)
{
	using namespace std::placeholders;
	session->remove(*key).connect(std::bind(&on_remove, on_chunk_context, _1),
				      std::bind(&on_finish, final_context, _1));
}

void session_bulk_remove(ell_session *session, context_t on_chunk_context, context_t final_context, void *ekeys)
{
	using namespace std::placeholders;

	ell_keys *keys = (ell_keys *)ekeys;

	for (auto it = keys->kk.begin(); it != keys->kk.end(); ++it) {
		it->transform(*session);
	}

	session->set_filter(elliptics::filters::all_with_ack);
	session->bulk_remove(keys->kk).connect(std::bind(&on_remove, on_chunk_context, _1),
				      std::bind(&on_finish, final_context, _1));
}

static void on_backend_status(context_t context, const std::vector<elliptics::backend_status_result_entry> &result,
		const elliptics::error_info &error)
{
	if (error) {
		go_error err {
			error.code(),
			0,
			error.message().c_str()
		};

		go_backend_status_error(context, &err);
		return;
	}

	struct dnet_backend_status_list *elements = result[0].list();
	go_backend_status_callback(context, elements);
}

void session_backends_status(ell_session *session, const struct dnet_addr *addr, context_t context)
{
	session->request_backends_status((*addr)).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}
void session_backend_start_defrag(ell_session *session, const struct dnet_addr *addr, uint32_t backend_id, context_t context)
{
	session->start_defrag((*addr), backend_id).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}
void session_backend_enable(ell_session *session, const struct dnet_addr *addr, uint32_t backend_id, context_t context)
{
	session->enable_backend((*addr), backend_id).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}
void session_backend_disable(ell_session *session, const struct dnet_addr *addr, uint32_t backend_id, context_t context)
{
	session->disable_backend((*addr), backend_id).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}
void session_backend_make_writable(ell_session *session, const struct dnet_addr *addr, uint32_t backend_id, context_t context)
{
	session->make_writable((*addr), backend_id).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}
void session_backend_make_readonly(ell_session *session, const struct dnet_addr *addr, uint32_t backend_id, context_t context)
{
	session->make_readonly((*addr), backend_id).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}
void session_backend_set_delay(ell_session *session, const struct dnet_addr *addr, uint32_t backend_id, uint32_t delay, context_t context)
{
	session->set_delay((*addr), backend_id, delay).connect(std::bind(&on_backend_status, context,
				std::placeholders::_1, std::placeholders::_2));
}

int session_lookup_addr(ell_session *session, const char *key, int len, int group_id, struct dnet_addr *addr, int *backend_id)
{
	return dnet_lookup_addr(session->get_native(), key, len, NULL, group_id, addr, backend_id);
}

// Iterators

void on_iterator(context_t context, const elliptics::iterator_result_entry &result)
{
	elliptics::data_pointer data(result.reply_data());
	go_iterator_result to_go{
		result.reply(),
		(const char *)data.data(),
		data.size(),
		result.id()
	};

	go_iterator_callback(&to_go, context);
}

void session_start_iterator(ell_session *session, context_t on_chunk_context, context_t final_context,
			const struct go_iterator_range* ranges, size_t range_count,
			const ell_key *key,
			uint64_t type,
			uint64_t flags,
			struct dnet_time time_begin,
			struct dnet_time time_end)
{
	std::vector<dnet_iterator_range> it_ranges(range_count);
	for (size_t i = 0; i < range_count; i++) {
		dnet_iterator_range range;
		std::memcpy(range.key_begin.id, ranges[i].key_begin, DNET_ID_SIZE);
		std::memcpy(range.key_end.id, ranges[i].key_end, DNET_ID_SIZE);

		it_ranges.push_back(range);
	}

	session->start_iterator(*key, it_ranges, type, flags, time_begin, time_end).connect(
		std::bind(&on_iterator, on_chunk_context, ph::_1),
		std::bind(&on_finish, final_context, ph::_1));
}

void session_start_copy_iterator(ell_session *session, context_t on_chunk_context, context_t final_context,
			const struct go_iterator_range* ranges, size_t range_count,
			uint32_t *groups, size_t groups_count,
			const ell_key *key,
			uint64_t flags,
			struct dnet_time time_begin,
			struct dnet_time time_end)
{
	std::vector<dnet_iterator_range> it_ranges(range_count);
	for (size_t i = 0; i < range_count; i++) {
		dnet_iterator_range range;
		std::memcpy(range.key_begin.id, ranges[i].key_begin, DNET_ID_SIZE);
		std::memcpy(range.key_end.id, ranges[i].key_end, DNET_ID_SIZE);

		it_ranges.push_back(range);
	}


	session->start_copy_iterator(*key, it_ranges, flags, time_begin, time_end, std::vector<int>(groups, groups + groups_count)).connect(
		std::bind(&on_iterator, on_chunk_context, ph::_1),
		std::bind(&on_finish, final_context, ph::_1));
}

void session_pause_iterator(ell_session *session, context_t on_chunk_context, context_t final_context,
		ell_key *key, uint64_t iterator_id)
{
	session->pause_iterator(*key, iterator_id).connect(
		std::bind(&on_iterator, on_chunk_context, ph::_1),
		std::bind(&on_finish, final_context, ph::_1));
}


void session_continue_iterator(ell_session *session, context_t on_chunk_context, context_t final_context,
		ell_key *key, uint64_t iterator_id)
{
	session->continue_iterator(*key, iterator_id).connect(
		std::bind(&on_iterator, on_chunk_context, ph::_1),
		std::bind(&on_finish, final_context, ph::_1));
}

void session_cancel_iterator(ell_session *session, context_t on_chunk_context, context_t final_context,
		ell_key *key, uint64_t iterator_id)
{
	session->cancel_iterator(*key, iterator_id).connect(
		std::bind(&on_iterator, on_chunk_context, ph::_1),
		std::bind(&on_finish, final_context, ph::_1));
}

void session_server_send(ell_session *session, context_t on_chunk_context, context_t final_context,
			void *ekeys,
			uint64_t flags,
			uint32_t *groups, size_t groups_count)
{
	ell_dnet_raw_id_keys *keys = (ell_dnet_raw_id_keys *)ekeys;

	session->server_send(keys->ids, flags, std::vector<int>(groups, groups + groups_count)).connect(
		std::bind(&on_iterator, on_chunk_context, ph::_1),
		std::bind(&on_finish, final_context, ph::_1));
}

} // extern "C"
